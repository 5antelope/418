FUNCTION  Powerline#Functions#fugitive#GetBranch()
Called 7 times
Total time:   0.002749
 Self time:   0.000170

count  total (s)   self (s)
    7   0.002616   0.000037 	let ret = fugitive#statusline()
                            
    7              0.000111 	let ret = substitute(ret, '\c\v\[?GIT\(([a-z0-9\-_\./:]+)\)\]?', a:symbol .' \1', 'g')
                            
    7              0.000009 	return ret

FUNCTION  neocomplcache#util#uniq()
Called 1 time
Total time:   0.000048
 Self time:   0.000010

count  total (s)   self (s)
    1   0.000047   0.000009   return call(s:List.uniq, a:000)

FUNCTION  neocomplcache#init#_sources()
Called 1 time
Total time:   0.072008
 Self time:   0.005377

count  total (s)   self (s)
    1              0.000003   if !exists('s:loaded_source_files')
                                " Initialize.
    1              0.000002     let s:loaded_source_files = {}
    1              0.000001     let s:loaded_all_sources = 0
    1              0.000001     let s:runtimepath_save = ''
    1              0.000001   endif
                            
                              " Initialize sources table.
    1              0.000002   if s:loaded_all_sources && &runtimepath ==# s:runtimepath_save
                                return
                              endif
                            
    1   0.000029   0.000009   let runtimepath_save = neocomplcache#util#split_rtp(s:runtimepath_save)
    1   0.001422   0.000182   let runtimepath = neocomplcache#util#join_rtp( filter(neocomplcache#util#split_rtp(), 'index(runtimepath_save, v:val) < 0'))
    1   0.000020   0.000013   let sources = neocomplcache#variables#get_sources()
                            
    2              0.000010   for name in filter(copy(a:names), '!has_key(sources, v:val)')
                                " Search autoload.
   11              0.003025     for source_name in map(split(globpath(runtimepath, 'autoload/neocomplcache/sources/*.vim'), '\n'), "fnamemodify(v:val, ':t:r')")
   10              0.000032       if has_key(s:loaded_source_files, source_name)
                                    continue
                                  endif
                            
   10              0.000029       let s:loaded_source_files[source_name] = 1
                            
   10   0.060231   0.001890       let source = neocomplcache#sources#{source_name}#define()
   10              0.000022       if empty(source)
                                    " Ignore.
                                    continue
                                  endif
                            
   10   0.007069   0.000046       call neocomplcache#define_source(source)
   10              0.000006     endfor
                            
    1              0.000002     if name == '_'
    1              0.000002       let s:loaded_all_sources = 1
    1              0.000005       let s:runtimepath_save = &runtimepath
    1              0.000001     endif
    1              0.000001   endfor

FUNCTION  neocomplcache#get_context_filetype()
Called 2 times
Total time:   0.000032
 Self time:   0.000017

count  total (s)   self (s)
    2   0.000026   0.000011   if !neocomplcache#is_enabled()
    2              0.000003     return &filetype
                              endif
                            
                              let neocomplcache = neocomplcache#get_current_neocomplcache()
                            
                              if a:0 != 0 || mode() !=# 'i' || neocomplcache.context_filetype == ''
                                call neocomplcache#context_filetype#set()
                              endif
                            
                              return neocomplcache.context_filetype

FUNCTION  <SNR>109_GetNearbyTag()
Called 7 times
Total time:   0.000021
 Self time:   0.000021

count  total (s)   self (s)
    7              0.000008     if s:nearby_disabled
    7              0.000007         return {}
                                endif
                            
                                let fileinfo = s:known_files.getCurrent(a:forcecurrent)
                                if empty(fileinfo)
                                    return {}
                                endif
                            
                                let typeinfo = fileinfo.typeinfo
                                if a:0 > 0
                                    let curline = a:1
                                else
                                    let curline = line('.')
                                endif
                                let tag = {}
                            
                                " If a tag appears in a file more than once (for example namespaces in
                                " C++) only one of them has a 'tline' entry and can thus be highlighted.
                                " The only way to solve this would be to go over the whole tag list again,
                                " making everything slower. Since this should be a rare occurence and
                                " highlighting isn't /that/ important ignore it for now.
                                for line in range(curline, 1, -1)
                                    if has_key(fileinfo.fline, line)
                                        let curtag = fileinfo.fline[line]
                                        if a:all || typeinfo.getKind(curtag.fields.kind).stl
                                            let tag = curtag
                                            break
                                        endif
                                    endif
                                endfor
                            
                                return tag

FUNCTION  <SNR>113__unify_path()
Called 390 times
Total time:   0.033473
 Self time:   0.033473

count  total (s)   self (s)
  390              0.033164     return resolve(fnamemodify(a:path, ':p:gs?[\\/]\+?/?'))

FUNCTION  <SNR>70_shellslash()
Called 7 times
Total time:   0.000116
 Self time:   0.000063

count  total (s)   self (s)
    7   0.000082   0.000029   if s:winshell()
                                return s:gsub(a:path,'\\','/')
                              else
    7              0.000007     return a:path
                              endif

FUNCTION  606()
Called 1 time
Total time:   0.000001
 Self time:   0.000001

count  total (s)   self (s)

FUNCTION  neocomplcache#util#set_default_dictionary()
Called 35 times
Total time:   0.001637
 Self time:   0.000576

count  total (s)   self (s)
   35              0.000093   if !exists('s:disable_dictionaries')
                                let s:disable_dictionaries = {}
                              endif
                            
   35              0.000084   if has_key(s:disable_dictionaries, a:variable)
                                return
                              endif
                            
   35   0.001312   0.000251   call neocomplcache#util#set_dictionary_helper({a:variable}, a:keys, a:value)

FUNCTION  <SNR>114_substitute_path_separator()
Called 4 times
Total time:   0.000016
 Self time:   0.000016

count  total (s)   self (s)
    4              0.000014   return s:is_windows ? substitute(a:path, '\\', '/', 'g') : a:path

FUNCTION  neocomplcache#util#join_rtp()
Called 1 time
Total time:   0.001168
 Self time:   0.000370

count  total (s)   self (s)
    1   0.001168   0.000370   return join(map(copy(a:list), 's:escape(v:val)'), ',')

FUNCTION  <SNR>70_buffer_commit()
Called 7 times
Total time:   0.000264
 Self time:   0.000074

count  total (s)   self (s)
    7   0.000260   0.000070   return matchstr(self.spec(),'^fugitive://.\{-\}//\zs\w*')

FUNCTION  <SNR>113__is_absolute_path()
Called 3 times
Total time:   0.000009
 Self time:   0.000009

count  total (s)   self (s)
    3              0.000009     return a:path[0] ==# '/'

FUNCTION  neocomplcache#get_context()
Called 10 times
Total time:   0.000147
 Self time:   0.000044

count  total (s)   self (s)
   10   0.000146   0.000043   return neocomplcache#get_current_neocomplcache().context

FUNCTION  <SNR>127_initialize_variables()
Called 2 times
Total time:   0.000960
 Self time:   0.000171

count  total (s)   self (s)
    2              0.000005   let s:include_info = {}
    2              0.000004   let s:include_cache = {}
    2              0.000002   let s:cache_accessed_time = {}
    2              0.000003   let s:async_include_cache = {}
    2              0.000004   let s:cached_pattern = {}
                            
                              " Initialize include pattern. "{{{
    2              0.000014   let g:neocomplcache_include_patterns = get(g:, 'neocomplcache_include_patterns', {})
    2   0.000121   0.000010   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_include_patterns', 'java,haskell', '^\s*\<import')
    2   0.000091   0.000012   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_include_patterns', 'cs', '^\s*\<using')
    2   0.000089   0.000012   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_include_patterns', 'ruby', '^\s*\<\%(load\|require\|require_relative\)\>')
    2   0.000100   0.000009   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_include_patterns', 'c,cpp', '^\s*#\s*include')
                              "}}}
                              " Initialize expr pattern. "{{{
    2   0.000038   0.000013   call neocomplcache#util#set_default( 'g:neocomplcache_include_exprs', {})
    2   0.000097   0.000010   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_include_exprs', 'haskell,cs', "substitute(v:fname, '\\.', '/', 'g')")
                              "}}}
                              " Initialize path pattern. "{{{
    2   0.000032   0.000009   call neocomplcache#util#set_default( 'g:neocomplcache_include_paths', {})
    2   0.000098   0.000010   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_include_paths', 'c,cpp', &path)
                              "}}}
                              " Initialize include suffixes. "{{{
    2   0.000037   0.000009   call neocomplcache#util#set_default( 'g:neocomplcache_include_suffixes', {})
    2   0.000085   0.000008   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_include_suffixes', 'haskell', '.hs')
                              "}}}
                              " Initialize include functions. "{{{
    2   0.000035   0.000010   call neocomplcache#util#set_default( 'g:neocomplcache_include_functions', {})
                              " call neocomplcache#util#set_default_dictionary(
                              "       \ 'g:neocomplcache_include_functions', 'vim',
                              "       \ 'neocomplcache#sources#include_complete#analyze_vim_include_files')
    2   0.000089   0.000011   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_include_functions', 'ruby', 'neocomplcache#sources#include_complete#analyze_ruby_include_files')
                              "}}}

FUNCTION  <SNR>113_import()
Called 1 time
Total time:   0.018568
 Self time:   0.000064

count  total (s)   self (s)
    1              0.000003   let target = {}
    1              0.000001   let functions = []
    1              0.000001   for a in a:000
                                if type(a) == type({})
                                  let target = a
                                elseif type(a) == type([])
                                  let functions = a
                                endif
                                unlet a
                              endfor
    1   0.018527   0.000023   let module = s:_import(a:name, s:_scripts())
    1              0.000002   if empty(functions)
    1              0.000014     call extend(target, module, 'keep')
    1              0.000001   else
                                for f in functions
                                  if has_key(module, f) && !has_key(target, f)
                                    let target[f] = module[f]
                                  endif
                                endfor
                              endif
    1              0.000001   return target

FUNCTION  neocomplcache#sources#filename_include#define()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return s:source

FUNCTION  <SNR>109_Init()
Called 7 times
Total time:   0.000163
 Self time:   0.000163

count  total (s)   self (s)
    7              0.000012     if s:checked_ctags == 2 && a:silent
                                    return 0
                                elseif s:checked_ctags != 1
                                    if !s:CheckForExCtags(a:silent)
                                        return 0
                                    endif
                                endif
                            
    7              0.000009     if !s:checked_ctags_types
                                    call s:GetSupportedFiletypes()
                                endif
                            
    7              0.000007     if !s:type_init_done
                                    call s:InitTypes()
                                endif
                            
    7              0.000008     if !s:autocommands_done
                                    call s:CreateAutocommands()
                                    call s:AutoUpdate(fnamemodify(expand('%'), ':p'), 0)
                                endif
                            
    7              0.000004     return 1

FUNCTION  301()
Called 7 times
Total time:   0.000059
 Self time:   0.000059

count  total (s)   self (s)
    7              0.000027     if !exists('b:syntastic_loclist') || empty(b:syntastic_loclist)
                                    let b:syntastic_loclist = g:SyntasticLoclist.New([])
                                endif
    7              0.000009     return b:syntastic_loclist

FUNCTION  <SNR>113__import()
Called 3 times
Total time:   0.006214
 Self time:   0.000132

count  total (s)   self (s)
    3              0.000011   if type(a:name) == type(0)
                                return s:_build_module(a:name)
                              endif
    3   0.006056   0.000023   let path = s:_get_module_path(a:name)
    3              0.000008   if path ==# ''
                                throw 'vital: module not found: ' . a:name
                              endif
    3              0.000011   let sid = get(a:scripts, path, 0)
    3              0.000003   if !sid
                                try
                                  execute 'source' fnameescape(path)
                                catch /^Vim\%((\a\+)\)\?:E484/
                                  throw 'vital: module not found: ' . a:name
                                catch /^Vim\%((\a\+)\)\?:E127/
                                  " Ignore.
                                endtry
                            
                                let sid = len(a:scripts) + 1  " We expect that the file newly read is +1.
                                let a:scripts[path] = sid
                              endif
    3   0.000069   0.000020   return s:_build_module(sid)

FUNCTION  310()
Called 7 times
Total time:   0.000374
 Self time:   0.000374

count  total (s)   self (s)
    7              0.000018     if !exists('self._stl_format')
                                    let self._stl_format = ''
                                endif
    7              0.000011     if !exists('self._stl_flag')
                                    let self._stl_flag = ''
                                endif
                            
    7              0.000012     if g:syntastic_stl_format !=# self._stl_format
                                    let self._stl_format = g:syntastic_stl_format
                            
                                    if !empty(self._rawLoclist)
                                        let errors = self.errors()
                                        let warnings = self.warnings()
                            
                                        let num_errors = len(errors)
                                        let num_warnings = len(warnings)
                                        let num_issues = len(self._rawLoclist)
                            
                                        let output = self._stl_format
                            
                                        "hide stuff wrapped in %E(...) unless there are errors
                                        let output = substitute(output, '\m\C%E{\([^}]*\)}', num_errors ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %W(...) unless there are warnings
                                        let output = substitute(output, '\m\C%W{\([^}]*\)}', num_warnings ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %B(...) unless there are both errors and warnings
                                        let output = substitute(output, '\m\C%B{\([^}]*\)}', (num_warnings && num_errors) ? '\1' : '' , 'g')
                            
                                        let flags = { '%':  '%', 't':  num_issues, 'e':  num_errors, 'w':  num_warnings, 'N':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':t') : ''), 'P':  (num_issues ? fnamemodify( bufname(self._rawLoclist[0]['bufnr']), ':p:~:.') : ''), 'F':  (num_issues ? self._rawLoclist[0]['lnum'] : ''), 'ne': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':t') : ''), 'pe': (num_errors ? fnamemodify( bufname(errors[0]['bufnr']), ':p:~:.') : ''), 'fe': (num_errors ? errors[0]['lnum'] : ''), 'nw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':t') : ''), 'pw': (num_warnings ? fnamemodify( bufname(warnings[0]['bufnr']), ':p:~:.') : ''), 'fw': (num_warnings ? warnings[0]['lnum'] : '') }
                                        let output = substitute(output, '\v\C\%(-?\d*%(\.\d+)?)([npf][ew]|[NPFtew%])', '\=syntastic#util#wformat(submatch(1), flags[submatch(2)])', 'g')
                            
                                        let self._stl_flag = output
                                    else
                                        let self._stl_flag = ''
                                    endif
                                endif
                            
    7              0.000011     return self._stl_flag

FUNCTION  Pl#Statusline()
Called 7 times
Total time:   0.000348
 Self time:   0.000348

count  total (s)   self (s)
    7              0.000055 		let mode = mode()
                            
    7              0.000013 		if ! a:current
                            			let mode = 'N' " Normal (non-current)
                            		elseif mode =~# '\v(v|V|)'
                            			let mode = 'v' " Visual mode
                            		elseif mode =~# '\v(s|S|)'
                            			let mode = 's' " Select mode
                            		elseif mode =~# '\vi'
                            			let mode = 'i' " Insert mode
                            		elseif mode =~# '\v(R|Rv)'
                            			let mode = 'r' " Replace mode
                            		else
                            			" Fallback to normal mode
    7              0.000007 			let mode = 'n' " Normal (current)
    7              0.000005 		endif
                            
    7              0.000048 		return g:Pl#THEME[a:statusline].mode_statuslines[mode]

FUNCTION  neocomplcache#init#lazy()
Called 2 times
Total time:   0.073182
 Self time:   0.000346

count  total (s)   self (s)
    2              0.000021   if !exists('s:lazy_progress')
                                let s:lazy_progress = 0
                              endif
                            
    2              0.000004   if s:lazy_progress == 0
                                call neocomplcache#init#_others()
                                let s:is_enabled = 0
                              elseif s:lazy_progress == 1
    1   0.072822   0.000269     call neocomplcache#init#_sources(get(g:neocomplcache_sources_list, neocomplcache#get_context_filetype(), ['_']))
    1              0.000000   else
    1   0.000292   0.000009     call neocomplcache#init#_autocmds()
    1              0.000003     let s:is_enabled = 1
    1              0.000000   endif
                            
    2              0.000004   let s:lazy_progress += 1

FUNCTION  neocomplcache#sources#omni_complete#define()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000002   return s:source

FUNCTION  neocomplcache#util#split_rtp()
Called 2 times
Total time:   0.000092
 Self time:   0.000092

count  total (s)   self (s)
    2              0.000006   let rtp = a:0 ? a:1 : &runtimepath
    2              0.000006   if type(rtp) == type([])
                                return rtp
                              endif
                            
    2              0.000032   if rtp !~ '\\'
    2              0.000042     return split(rtp, ',')
                              endif
                            
                              let split = split(rtp, '\\\@<!\%(\\\\\)*\zs,')
                              return map(split,'substitute(v:val, ''\\\([\\,]\)'', "\\1", "g")')

FUNCTION  neocomplcache#sources#dictionary_complete#recaching()
Called 1 time
Total time:   0.000137
 Self time:   0.000056

count  total (s)   self (s)
    1              0.000003   if !exists('g:neocomplcache_dictionary_filetype_lists')
                                call neocomplcache#initialize()
                              endif
                            
    1              0.000002   let filetype = a:filetype
    1              0.000001   if filetype == ''
                                let filetype = neocomplcache#get_context_filetype(1)
                              endif
                            
                              " Caching.
    1              0.000003   let dictionaries = get( g:neocomplcache_dictionary_filetype_lists, filetype, '')
                            
    1              0.000001   if dictionaries == ''
    1              0.000002     if filetype != &filetype && &l:dictionary != '' && &l:dictionary !=# &g:dictionary
                                  let dictionaries .= &l:dictionary
                                endif
    1              0.000000   endif
                            
    1              0.000003   let s:async_dictionary_list[filetype] = []
                            
    1   0.000094   0.000013   let pattern = get(g:neocomplcache_dictionary_patterns, filetype, neocomplcache#get_keyword_pattern(filetype))
    1              0.000005   for dictionary in split(dictionaries, ',')
                                let dictionary = neocomplcache#util#substitute_path_separator( fnamemodify(dictionary, ':p'))
                                if filereadable(dictionary)
                                  call neocomplcache#print_debug('Caching dictionary: ' . dictionary)
                                  call add(s:async_dictionary_list[filetype], { 'filename' : dictionary, 'cachename' : neocomplcache#cache#async_load_from_file(       'dictionary_cache', dictionary, pattern, 'D') })
                                endif
                              endfor

FUNCTION  neocomplcache#exists_echodoc()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return exists('g:loaded_echodoc') && g:loaded_echodoc

FUNCTION  <SNR>114_set_dictionary_helper()
Called 35 times
Total time:   0.000863
 Self time:   0.000863

count  total (s)   self (s)
   99              0.000335   for key in split(a:keys, '\s*,\s*')
   64              0.000140     if !has_key(a:variable, key)
   52              0.000131       let a:variable[key] = a:pattern
   52              0.000026     endif
   64              0.000047   endfor

FUNCTION  neocomplcache#init#is_enabled()
Called 2 times
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    2              0.000003   return s:is_enabled

FUNCTION  <SNR>70_repo_head_ref()
Called 7 times
Total time:   0.000969
 Self time:   0.000877

count  total (s)   self (s)
    7   0.000494   0.000452   if !filereadable(self.dir('HEAD'))
                                return ''
                              endif
    7   0.000446   0.000396   return readfile(self.dir('HEAD'))[0]

FUNCTION  <SNR>70_buffer()
Called 7 times
Total time:   0.000252
 Self time:   0.000222

count  total (s)   self (s)
    7              0.000040   let buffer = {'#': bufnr(a:0 ? a:1 : '%')}
    7              0.000123   call extend(extend(buffer,s:buffer_prototype,'keep'),s:abstract_prototype,'keep')
    7   0.000074   0.000044   if buffer.getvar('git_dir') !=# ''
    7              0.000008     return buffer
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  neocomplcache#has_vimproc()
Called 1 time
Total time:   0.001763
 Self time:   0.000008

count  total (s)   self (s)
    1   0.001763   0.000008   return neocomplcache#util#has_vimproc()

FUNCTION  <SNR>130_caching()
Called 1 time
Total time:   0.000005
 Self time:   0.000005

count  total (s)   self (s)
    1              0.000004   if &filetype == '' || &filetype ==# 'vim'
    1              0.000001     return
                              endif
                            
                              for filetype in neocomplcache#get_source_filetypes(&filetype)
                                if !has_key(s:syntax_list, filetype)
                                  " Check old cache.
                                  let cache_name = neocomplcache#cache#encode_name('syntax_cache', &filetype)
                                  let syntax_files = split( globpath(&runtimepath, 'syntax/'.&filetype.'.vim'), '\n')
                                  if getftime(cache_name) < 0 || (!empty(syntax_files) && getftime(cache_name) <= getftime(syntax_files[0]))
                                    if filetype ==# &filetype
                                      " Caching from syn list.
                                      let s:syntax_list[filetype] = s:caching_from_syn(filetype)
                                    endif
                                  else
                                    let s:syntax_list[filetype] = neocomplcache#cache#index_load_from_cache(      'syntax_cache', filetype, 1)
                                  endif
                                endif
                              endfor

FUNCTION  <SNR>113__build_module()
Called 3 times
Total time:   0.000049
 Self time:   0.000049

count  total (s)   self (s)
    3              0.000010   if has_key(s:loaded, a:sid)
    3              0.000036     return copy(s:loaded[a:sid])
                              endif
                              let prefix = '<SNR>' . a:sid . '_'
                              let funcs = s:_redir('function')
                              let filter_pat = '^\s*function ' . prefix
                              let map_pat = prefix . '\zs\w\+'
                              let functions = map(filter(split(funcs, "\n"), 'v:val =~# filter_pat'),          'matchstr(v:val, map_pat)')
                            
                              let module = {}
                              for func in functions
                                let module[func] = function(prefix . func)
                              endfor
                              if has_key(module, '_vital_loaded')
                                let V = vital#{s:self_version}#new()
                                if has_key(module, '_vital_depends')
                                  call call(V.load, module._vital_depends(), V)
                                endif
                                try
                                  call module._vital_loaded(V)
                                catch
                                  " FIXME: Show an error message for debug.
                                endtry
                              endif
                              if !get(g:, 'vital_debug', 0)
                                call filter(module, 'v:key =~# "^\\a"')
                              endif
                              let s:loaded[a:sid] = module
                              return copy(module)

FUNCTION  neocomplcache#util#convert2list()
Called 10 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
   10              0.000036   return type(a:expr) ==# type([]) ? a:expr : [a:expr]

FUNCTION  <SNR>111_escape()
Called 92 times
Total time:   0.000798
 Self time:   0.000798

count  total (s)   self (s)
   92              0.000754   return substitute(a:path, ',\|\\,\@=', '\\\0', 'g')

FUNCTION  neocomplcache#is_enabled()
Called 2 times
Total time:   0.000015
 Self time:   0.000011

count  total (s)   self (s)
    2   0.000015   0.000011   return neocomplcache#init#is_enabled()

FUNCTION  628()
Called 1 time
Total time:   0.000102
 Self time:   0.000026

count  total (s)   self (s)
    1              0.000004   let g:neocomplcache_tags_caching_limit_file_size = get(g:, 'neocomplcache_tags_caching_limit_file_size', 500000)
                            
                              " Create cache directory.
    1   0.000092   0.000016   if !isdirectory(neocomplcache#get_temporary_directory() . '/tags_cache') && !neocomplcache#util#is_sudo()
                                call mkdir(neocomplcache#get_temporary_directory() . '/tags_cache', 'p')
                              endif

FUNCTION  <SNR>113__get_module_path()
Called 3 times
Total time:   0.006033
 Self time:   0.005691

count  total (s)   self (s)
    3   0.000028   0.000019   if s:_is_absolute_path(a:name) && filereadable(a:name)
                                return s:_unify_path(a:name)
                              endif
    3              0.000003   if a:name ==# ''
    1              0.000005     let tailpath = printf('autoload/vital/%s.vim', s:self_version)
    1              0.000001   elseif a:name =~# '\v^\u\w*%(\.\u\w*)*$'
    2              0.000013     let target = '/' . substitute(a:name, '\W\+', '/', 'g')
    2              0.000012     let tailpath = printf('autoload/vital/%s%s.vim', s:self_version, target)
    2              0.000001   else
                                let tailpath = a:name
                              endif
                            
                              " Note: The extra argument to globpath() was added in Patch 7.2.051.
    3              0.000007   if v:version > 702 || v:version == 702 && has('patch51')
    3              0.005382     let paths = split(globpath(&runtimepath, tailpath, 1), "\n")
    3              0.000008   else
                                let paths = split(globpath(&runtimepath, tailpath), "\n")
                              endif
    3              0.000146   call filter(paths, 'filereadable(v:val)')
    3   0.000366   0.000033   return s:_unify_path(get(paths, 0, ''))

FUNCTION  614()
Called 1 time
Total time:   0.002382
 Self time:   0.000063

count  total (s)   self (s)
    1   0.000464   0.000004   call s:initialize_variables()
                            
    1   0.001771   0.000008   if neocomplcache#has_vimproc()
                                augroup neocomplcache
                                  " Caching events
                                  autocmd BufWritePost * call s:check_buffer('', 0)
                                  autocmd CursorHold * call s:check_cache()
                                augroup END
                              endif
                            
    1   0.000022   0.000006   call neocomplcache#util#set_default( 'g:neocomplcache_include_max_processes', 20)
                            
                              " Create cache directory.
    1   0.000099   0.000023   if !isdirectory(neocomplcache#get_temporary_directory() . '/include_cache') && !neocomplcache#util#is_sudo()
                                call mkdir(neocomplcache#get_temporary_directory() . '/include_cache', 'p')
                              endif
                            
    1   0.000013   0.000009   if neocomplcache#exists_echodoc()
                                call echodoc#register('include_complete', s:doc_dict)
                              endif

FUNCTION  <SNR>113__redir()
Called 3 times
Total time:   0.000789
 Self time:   0.000789

count  total (s)   self (s)
    3              0.000014   let [save_verbose, save_verbosefile] = [&verbose, &verbosefile]
    3              0.000024   set verbose=0 verbosefile=
    3              0.000011   redir => res
    3              0.000702     silent! execute a:cmd
    3              0.000012   redir END
    3              0.000015   let [&verbose, &verbosefile] = [save_verbose, save_verbosefile]
    3              0.000007   return res

FUNCTION  neocomplcache#sources#filename_complete#define()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return s:source

FUNCTION  neocomplcache#helper#unite_patterns()
Called 1 time
Total time:   0.000066
 Self time:   0.000066

count  total (s)   self (s)
    1              0.000002   let keyword_patterns = []
    1              0.000001   let dup_check = {}
                            
                              " Composite filetype.
    2              0.000007   for ft in split(a:filetype, '\.')
    1              0.000003     if has_key(a:pattern_var, ft) && !has_key(dup_check, ft)
                                  let dup_check[ft] = 1
                                  call add(keyword_patterns, a:pattern_var[ft])
                                endif
                            
                                " Same filetype.
    1              0.000005     if exists('g:neocomplcache_same_filetype_lists') && has_key(g:neocomplcache_same_filetype_lists, ft)
                                  for ft in split(g:neocomplcache_same_filetype_lists[ft], ',')
                                    if has_key(a:pattern_var, ft) && !has_key(dup_check, ft)
                                      let dup_check[ft] = 1
                                      call add(keyword_patterns, a:pattern_var[ft])
                                    endif
                                  endfor
                                endif
    1              0.000001   endfor
                            
    1              0.000001   if empty(keyword_patterns)
    1              0.000005     let default = get(a:pattern_var, '_', get(a:pattern_var, 'default', ''))
    1              0.000001     if default != ''
    1              0.000005       call add(keyword_patterns, default)
    1              0.000001     endif
    1              0.000000   endif
                            
    1              0.000004   return join(keyword_patterns, '\m\|')

FUNCTION  neocomplcache#sources#member_complete#define()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return s:source

FUNCTION  neocomplcache#variables#get_sources()
Called 11 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
   11              0.000026   if !exists('s:sources')
    1              0.000002     let s:sources = {}
    1              0.000001   endif
   11              0.000012   return s:sources

FUNCTION  neocomplcache#get_temporary_directory()
Called 4 times
Total time:   0.000329
 Self time:   0.000135

count  total (s)   self (s)
    4   0.000242   0.000048   let directory = neocomplcache#util#substitute_path_separator( neocomplcache#util#expand(g:neocomplcache_temporary_dir))
    4              0.000060   if !isdirectory(directory) && !neocomplcache#util#is_sudo()
                                call mkdir(directory, 'p')
                              endif
                            
    4              0.000005   return directory

FUNCTION  fugitive#head()
Called 7 times
Total time:   0.001798
 Self time:   0.000093

count  total (s)   self (s)
    7              0.000017   if !exists('b:git_dir')
                                return ''
                              endif
                            
    7   0.001764   0.000059   return s:repo().head(a:0 ? a:1 : 0)

FUNCTION  neocomplcache#get_current_neocomplcache()
Called 11 times
Total time:   0.000110
 Self time:   0.000086

count  total (s)   self (s)
   11              0.000026   if !exists('b:neocomplcache')
    1   0.000035   0.000011     call neocomplcache#init#_current_neocomplcache()
    1              0.000001   endif
                            
   11              0.000015   return b:neocomplcache

FUNCTION  <SNR>70_repo_head()
Called 7 times
Total time:   0.001514
 Self time:   0.000254

count  total (s)   self (s)
    7   0.001185   0.000064     let head = s:repo().head_ref()
                            
    7              0.000058     if head =~# '^ref: '
    7   0.000195   0.000056       let branch = s:sub(head,'^ref: %(refs/%(heads/|remotes/|tags/)=)=','')
    7              0.000013     elseif head =~# '^\x\{40\}$'
                                  " truncate hash to a:1 characters if we're in detached head mode
                                  let len = a:0 ? a:1 : 0
                                  let branch = len ? head[0:len-1] : ''
                                else
                                  return ''
                                endif
                            
    7              0.000007     return branch

FUNCTION  neocomplcache#sources#include_complete#define()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003   return s:source

FUNCTION  neocomplcache#get_source_filetypes()
Called 1 time
Total time:   0.000656
 Self time:   0.000175

count  total (s)   self (s)
    1   0.000655   0.000174   return neocomplcache#helper#get_source_filetypes(a:filetype)

FUNCTION  neocomplcache#sources#dictionary_complete#define()
Called 1 time
Total time:   0.000003
 Self time:   0.000003

count  total (s)   self (s)
    1              0.000003   return s:source

FUNCTION  neocomplcache#init#_autocmds()
Called 1 time
Total time:   0.000283
 Self time:   0.000283

count  total (s)   self (s)
    1              0.000004   augroup neocomplcache
    1              0.000225     autocmd!
    1              0.000016     autocmd InsertEnter * call neocomplcache#handler#_on_insert_enter()
    1              0.000006     autocmd InsertLeave * call neocomplcache#handler#_on_insert_leave()
    1              0.000004     autocmd CursorMovedI * call neocomplcache#handler#_on_moved_i()
    1              0.000003     autocmd BufWritePost * call neocomplcache#handler#_on_write_post()
    1              0.000002   augroup END
                            
    1              0.000005   if g:neocomplcache_enable_insert_char_pre && (v:version > 703 || v:version == 703 && has('patch418'))
                                autocmd neocomplcache InsertCharPre * call neocomplcache#handler#_do_auto_complete('InsertCharPre')
                              elseif g:neocomplcache_enable_cursor_hold_i
                                augroup neocomplcache
                                  autocmd CursorHoldI * call neocomplcache#handler#_do_auto_complete('CursorHoldI')
                                  autocmd InsertEnter * call neocomplcache#handler#_change_update_time()
                                  autocmd InsertLeave * call neocomplcache#handler#_restore_update_time()
                                augroup END
                              else
    1              0.000002     autocmd neocomplcache CursorMovedI * call neocomplcache#handler#_do_auto_complete('CursorMovedI')
    1              0.000001   endif
                            
    1              0.000003   if (v:version > 703 || v:version == 703 && has('patch598'))
    1              0.000003     autocmd neocomplcache CompleteDone * call neocomplcache#handler#_on_complete_done()
    1              0.000000   endif

FUNCTION  618()
Called 1 time
Total time:   0.000372
 Self time:   0.000071

count  total (s)   self (s)
    1              0.000003   augroup neocomplcache "{{{
                                " Caching events
    1              0.000010     autocmd CursorHold * call s:caching_current_buffer(line('.')-10, line('.')+10)
    1              0.000009     autocmd InsertEnter,InsertLeave * call neocomplcache#sources#member_complete#caching_current_line()
    1              0.000001   augroup END"}}}
                            
                              " Initialize member prefix patterns. "{{{
    1              0.000004   if !exists('g:neocomplcache_member_prefix_patterns')
    1              0.000003     let g:neocomplcache_member_prefix_patterns = {}
    1              0.000000   endif
    1   0.000075   0.000006   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_member_prefix_patterns', 'c,cpp,objc,objcpp', '\.\|->')
    1   0.000055   0.000005   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_member_prefix_patterns', 'perl,php', '->')
    1   0.000111   0.000006   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_member_prefix_patterns', 'cs,java,javascript,d,vim,ruby,python,perl6,scala,vb', '\.')
    1   0.000045   0.000006   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_member_prefix_patterns', 'lua', '\.\|:')
                              "}}}
                            
                              " Initialize member patterns. "{{{
    1              0.000003   if !exists('g:neocomplcache_member_patterns')
    1              0.000002     let g:neocomplcache_member_patterns = {}
    1              0.000001   endif
    1   0.000044   0.000006   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_member_patterns','default', '\h\w*\%(()\|\[\h\w*\]\)\?')
                              "}}}
                            
                              " Initialize script variables. "{{{
    1              0.000002   let s:member_sources = {}
                              "}}}

FUNCTION  tagbar#currenttag()
Called 7 times
Total time:   0.000434
 Self time:   0.000250

count  total (s)   self (s)
                                " Indicate that the statusline functionality is being used. This prevents
                                " the CloseWindow() function from removing the autocommands.
    7              0.000018     let s:statusline_in_use = 1
                            
    7              0.000009     if a:0 > 0
                                    " also test for non-zero value for backwards compatibility
                                    let longsig   = a:1 =~# 's' || (type(a:1) == type(0) && a:1 != 0)
                                    let fullpath  = a:1 =~# 'f'
                                    let prototype = a:1 =~# 'p'
                                else
    7              0.000010         let longsig   = 0
    7              0.000008         let fullpath  = 0
    7              0.000007         let prototype = 0
    7              0.000007     endif
                            
    7   0.000191   0.000028     if !s:Init(1)
                                    return a:default
                                endif
                            
    7   0.000052   0.000031     let tag = s:GetNearbyTag(0, 1)
                            
    7              0.000010     if !empty(tag)
                                    if prototype
                                        return tag.getPrototype(1)
                                    else
                                        return printf(a:fmt, tag.str(longsig, fullpath))
                                    endif
                                else
    7              0.000009         return a:default
                                endif

FUNCTION  Powerline#Functions#syntastic#GetErrors()
Called 7 times
Total time:   0.000648
 Self time:   0.000161

count  total (s)   self (s)
    7              0.000022 	if ! exists('g:syntastic_stl_format')
                            		" Syntastic hasn't been loaded yet
                            		return ''
                            	endif
                            
                            	" Temporarily change syntastic output format
    7              0.000016 	let old_stl_format = g:syntastic_stl_format
    7              0.000028 	let g:syntastic_stl_format = '%E{ ERRORS (%e) '. a:line_symbol .' %fe }%W{ WARNINGS (%w) '. a:line_symbol .' %fw }'
                            
    7   0.000522   0.000035 	let ret = SyntasticStatuslineFlag()
                            
    7              0.000017 	let g:syntastic_stl_format = old_stl_format
                            
    7              0.000005 	return ret

FUNCTION  neocomplcache#util#set_dictionary_helper()
Called 35 times
Total time:   0.001061
 Self time:   0.000198

count  total (s)   self (s)
   35   0.001050   0.000187   return call(s:V.set_dictionary_helper, a:000)

FUNCTION  neocomplcache#util#has_vimproc()
Called 1 time
Total time:   0.001755
 Self time:   0.001755

count  total (s)   self (s)
                              " Initialize.
    1              0.000002   if !exists('g:neocomplcache_use_vimproc')
                                " Check vimproc.
    1              0.000001     try
    1              0.001713       call vimproc#version()
                                  let exists_vimproc = 1
                                catch
    1              0.000003       let exists_vimproc = 0
    1              0.000008     endtry
                            
    1              0.000003     let g:neocomplcache_use_vimproc = exists_vimproc
    1              0.000001   endif
                            
    1              0.000002   return g:neocomplcache_use_vimproc

FUNCTION  neocomplcache#is_text_mode()
Called 1 time
Total time:   0.000016
 Self time:   0.000009

count  total (s)   self (s)
    1   0.000011   0.000004   let neocomplcache = neocomplcache#get_current_neocomplcache()
    1              0.000003   return get(g:neocomplcache_text_mode_filetypes, neocomplcache.context_filetype, 0)

FUNCTION  <SNR>113__scripts()
Called 3 times
Total time:   0.047024
 Self time:   0.013095

count  total (s)   self (s)
    3              0.000006   let scripts = {}
  390   0.001634   0.000845   for line in split(s:_redir('scriptnames'), "\n")
  387              0.006571     let list = matchlist(line, '^\s*\(\d\+\):\s\+\(.\+\)\s*$')
  387              0.000786     if !empty(list)
  387   0.036701   0.003561       let scripts[s:_unify_path(list[2])] = list[1] - 0
  387              0.000556     endif
  387              0.000486   endfor
    3              0.000005   return scripts

FUNCTION  <SNR>70_repo()
Called 14 times
Total time:   0.000343
 Self time:   0.000343

count  total (s)   self (s)
   14              0.000082   let dir = a:0 ? a:1 : (exists('b:git_dir') && b:git_dir !=# '' ? b:git_dir : fugitive#extract_git_dir(expand('%:p')))
   14              0.000014   if dir !=# ''
   14              0.000030     if has_key(s:repos, dir)
   14              0.000037       let repo = get(s:repos, dir)
   14              0.000010     else
                                  let repo = {'git_dir': dir}
                                  let s:repos[dir] = repo
                                endif
   14              0.000098     return extend(extend(repo, s:repo_prototype, 'keep'), s:abstract_prototype, 'keep')
                              endif
                              call s:throw('not a git repository: '.expand('%:p'))

FUNCTION  neocomplcache#get_keyword_pattern()
Called 1 time
Total time:   0.000081
 Self time:   0.000015

count  total (s)   self (s)
    1              0.000004   let filetype = a:0 != 0? a:000[0] : neocomplcache#get_context_filetype()
                            
    1   0.000075   0.000009   return neocomplcache#helper#unite_patterns( g:neocomplcache_keyword_patterns, filetype)

FUNCTION  fugitive#statusline()
Called 7 times
Total time:   0.002579
 Self time:   0.000265

count  total (s)   self (s)
    7              0.000022   if !exists('b:git_dir')
                                return ''
                              endif
    7              0.000009   let status = ''
    7   0.000579   0.000063   if s:buffer().commit() != ''
                                let status .= ':' . s:buffer().commit()[0:7]
                              endif
    7   0.001840   0.000042   let status .= '('.fugitive#head(7).')'
    7              0.000051   if &statusline =~# '%[MRHWY]' && &statusline !~# '%[mrhwy]'
                                return ',GIT'.status
                              else
    7              0.000011     return '[Git'.status.']'
                              endif

FUNCTION  <SNR>70_buffer_getvar()
Called 7 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    7              0.000025   return getbufvar(self['#'],a:var)

FUNCTION  neocomplcache#sources#vim_complete#define()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return s:source

FUNCTION  neocomplcache#define_source()
Called 10 times
Total time:   0.007023
 Self time:   0.000226

count  total (s)   self (s)
   10   0.000102   0.000044   let sources = neocomplcache#variables#get_sources()
   20   0.000103   0.000061   for source in neocomplcache#util#convert2list(a:source)
   10   0.006768   0.000071     let sources[source.name] = neocomplcache#init#_source(source)
   10              0.000008   endfor

FUNCTION  neocomplcache#util#substitute_path_separator()
Called 4 times
Total time:   0.000053
 Self time:   0.000037

count  total (s)   self (s)
    4   0.000049   0.000033   return call(s:V.substitute_path_separator, a:000)

FUNCTION  603()
Called 1 time
Total time:   0.001034
 Self time:   0.000070

count  total (s)   self (s)
                              " Initialize dictionary. "{{{
    1              0.000003   if !exists('g:neocomplcache_dictionary_filetype_lists')
    1              0.000003     let g:neocomplcache_dictionary_filetype_lists = {}
    1              0.000000   endif
    1              0.000003   if !has_key(g:neocomplcache_dictionary_filetype_lists, 'default')
    1              0.000002     let g:neocomplcache_dictionary_filetype_lists['default'] = ''
    1              0.000000   endif
                              "}}}
                            
                              " Initialize dictionary completion pattern. "{{{
    1              0.000003   if !exists('g:neocomplcache_dictionary_patterns')
    1              0.000002     let g:neocomplcache_dictionary_patterns = {}
    1              0.000001   endif
                              "}}}
                            
                              " Set caching event.
    1              0.000013   autocmd neocomplcache FileType * call s:caching()
                            
                              " Create cache directory.
    1   0.000119   0.000021   if !isdirectory(neocomplcache#get_temporary_directory() . '/dictionary_cache') && !neocomplcache#util#is_sudo()
                                call mkdir(neocomplcache#get_temporary_directory() . '/dictionary_cache')
                              endif
                            
                              " Initialize check.
    1   0.000877   0.000011   call s:caching()

FUNCTION  neocomplcache#sources#tags_complete#define()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return s:source

FUNCTION  610()
Called 1 time
Total time:   0.000331
 Self time:   0.000051

count  total (s)   self (s)
                              " Initialize.
                            
                              " Initialize filename include expr. "{{{
    1              0.000004   let g:neocomplcache_filename_include_exprs = get(g:, 'neocomplcache_filename_include_exprs', {})
    1   0.000073   0.000010   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_filename_include_exprs', 'perl', 'fnamemodify(substitute(v:fname, "/", "::", "g"), ":r")')
    1   0.000068   0.000006   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_filename_include_exprs', 'ruby,python,java,d', 'fnamemodify(substitute(v:fname, "/", ".", "g"), ":r")')
                              "}}}
                            
                              " Initialize filename include extensions. "{{{
    1              0.000005   let g:neocomplcache_filename_include_exts = get(g:, 'neocomplcache_filename_include_exts', {})
    1   0.000047   0.000005   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_filename_include_exts', 'c', ['h'])
    1   0.000043   0.000005   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_filename_include_exts', 'cpp', ['', 'h', 'hpp', 'hxx'])
    1   0.000044   0.000006   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_filename_include_exts', 'perl', ['pm'])
    1   0.000042   0.000005   call neocomplcache#util#set_default_dictionary( 'g:neocomplcache_filename_include_exts', 'java', ['java'])
                              "}}}

FUNCTION  621()
Called 1 time
Total time:   0.001232
 Self time:   0.000864

count  total (s)   self (s)
                              " Initialize omni completion pattern. "{{{
    1              0.000004   if !exists('g:neocomplcache_omni_patterns')
                                let g:neocomplcache_omni_patterns = {}
                              endif
    1   0.000079   0.000005   call neocomplcache#util#set_default_dictionary('g:neocomplcache_omni_patterns','html,xhtml,xml,markdown','<[^>]*')
    1   0.000059   0.000005   call neocomplcache#util#set_default_dictionary('g:neocomplcache_omni_patterns','css,scss,sass','^\s\+\w\+\|\w\+[):;]\?\s\+\w*\|[@!]')
    1   0.000044   0.000006   call neocomplcache#util#set_default_dictionary('g:neocomplcache_omni_patterns','javascript','[^. \t]\.\%(\h\w*\)\?')
    1   0.000043   0.000005   call neocomplcache#util#set_default_dictionary('g:neocomplcache_omni_patterns','actionscript','[^. \t][.:]\h\w*')
                              "call neocomplcache#util#set_default_dictionary(
                                    "\'g:neocomplcache_omni_patterns',
                                    "\'php',
                                    "\'[^. \t]->\h\w*\|\h\w*::')
    1   0.000045   0.000006   call neocomplcache#util#set_default_dictionary('g:neocomplcache_omni_patterns','java','\%(\h\w*\|)\)\.')
                              "call neocomplcache#util#set_default_dictionary(
                                    "\'g:neocomplcache_omni_patterns',
                                    "\'perl',
                                    "\'\h\w*->\h\w*\|\h\w*::')
                              "call neocomplcache#util#set_default_dictionary(
                                    "\'g:neocomplcache_omni_patterns',
                                    "\'c',
                                    "\'[^.[:digit:] *\t]\%(\.\|->\)'
                              "call neocomplcache#util#set_default_dictionary(
                                    "\'g:neocomplcache_omni_patterns',
                                    "\'cpp',
                                    "\'[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::')
    1   0.000042   0.000004   call neocomplcache#util#set_default_dictionary('g:neocomplcache_omni_patterns','objc','[^.[:digit:] *\t]\%(\.\|->\)')
    1   0.000043   0.000005   call neocomplcache#util#set_default_dictionary('g:neocomplcache_omni_patterns','objj','[\[ \.]\w\+$\|:\w*$')
                            
                              " External language interface check.
    1              0.000396   if has('ruby')
                                " call neocomplcache#util#set_default_dictionary(
                                      "\'g:neocomplcache_omni_patterns', 'ruby',
                                      "\'[^. *\t]\.\h\w*\|\h\w*::')
    1              0.000002   endif
    1              0.000401   if has('python/dyn') || has('python3/dyn') || has('python') || has('python3')
    1   0.000058   0.000009     call neocomplcache#util#set_default_dictionary('g:neocomplcache_omni_patterns','python', '[^. \t]\.\w*')
    1              0.000001   endif
                              "}}}

FUNCTION  625()
Called 1 time
Total time:   0.000127
 Self time:   0.000043

count  total (s)   self (s)
                              " Set caching event.
    1              0.000012   autocmd neocomplcache Syntax * call s:caching()
                            
                              " Create cache directory.
    1   0.000095   0.000016   if !isdirectory(neocomplcache#get_temporary_directory() . '/syntax_cache') && !neocomplcache#util#is_sudo()
                                call mkdir(neocomplcache#get_temporary_directory() . '/syntax_cache')
                              endif
                            
                              " Initialize check.
    1   0.000013   0.000008   call s:caching()

FUNCTION  <SNR>70_buffer_spec()
Called 7 times
Total time:   0.000190
 Self time:   0.000074

count  total (s)   self (s)
    7              0.000028     let bufname = bufname(self['#'])
    7   0.000159   0.000043     return s:shellslash(bufname == '' ? '' : fnamemodify(bufname,':p'))

FUNCTION  neocomplcache#variables#get_custom()
Called 10 times
Total time:   0.000081
 Self time:   0.000081

count  total (s)   self (s)
   10              0.000020   if !exists('s:custom')
                                let s:custom = {}
                                let s:custom.sources = {}
                                let s:custom.sources._ = {}
                              endif
                            
   10              0.000016   return s:custom

FUNCTION  vital#_13055f8#new()
Called 1 time
Total time:   0.034886
 Self time:   0.000048

count  total (s)   self (s)
    1   0.034885   0.000047   return s:_import('', s:_scripts()).load(['Prelude', ''])

FUNCTION  <SNR>70_winshell()
Called 7 times
Total time:   0.000053
 Self time:   0.000053

count  total (s)   self (s)
    7              0.000046   return &shell =~? 'cmd' || exists('+shellslash') && !&shellslash

FUNCTION  neocomplcache#sources#buffer_complete#define()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000004   return s:source

FUNCTION  <SNR>109_IsValidFile()
Called 2 times
Total time:   0.000049
 Self time:   0.000025

count  total (s)   self (s)
    2   0.000021   0.000008     call s:debug('Checking if file is valid [' . a:fname . ']')
                            
    2              0.000004     if a:fname == '' || a:ftype == ''
    2   0.000018   0.000007         call s:debug('Empty filename or type')
    2              0.000002         return 0
                                endif
                            
                                if !filereadable(a:fname) && getbufvar(a:fname, 'netrw_tmpfile') == ''
                                    call s:debug('File not readable')
                                    return 0
                                endif
                            
                                if getbufvar(a:fname, 'tagbar_ignore') == 1
                                    call s:debug('File is marked as ignored')
                                    return 0
                                endif
                            
                                if &previewwindow
                                    call s:debug('In preview window')
                                    return 0
                                endif
                            
                                if !has_key(s:known_types, a:ftype)
                                    if exists('g:tagbar_type_' . a:ftype)
                                        " Filetype definition must have been specified in an 'ftplugin'
                                        " file, so load it now
                                        call s:LoadUserTypeDefs(a:ftype)
                                    else
                                        call s:debug('Unsupported filetype: ' . a:ftype)
                                        return 0
                                    endif
                                endif
                            
                                return 1

FUNCTION  <SNR>70_repo_dir()
Called 14 times
Total time:   0.000092
 Self time:   0.000092

count  total (s)   self (s)
   14              0.000083   return join([self.git_dir]+a:000,'/')

FUNCTION  neocomplcache#util#expand()
Called 4 times
Total time:   0.000141
 Self time:   0.000141

count  total (s)   self (s)
    4              0.000140   return expand(escape(a:path, '*?[]"={}'), 1)

FUNCTION  <SNR>115_uniq()
Called 1 time
Total time:   0.000038
 Self time:   0.000038

count  total (s)   self (s)
    1              0.000005   let list = a:0 ? map(copy(a:list), printf('[v:val, %s]', a:1)) : copy(a:list)
    1              0.000001   let i = 0
    1              0.000001   let seen = {}
    2              0.000003   while i < len(list)
    1              0.000005     let key = string(a:0 ? list[i][1] : list[i])
    1              0.000002     if has_key(seen, key)
                                  call remove(list, i)
                                else
    1              0.000002       let seen[key] = 1
    1              0.000001       let i += 1
    1              0.000001     endif
    1              0.000000   endwhile
    1              0.000002   return a:0 ? map(list, 'v:val[0]') : list

FUNCTION  <SNR>109_debug()
Called 10 times
Total time:   0.000065
 Self time:   0.000065

count  total (s)   self (s)
   10              0.000011     if s:debug
                                    execute 'redir >> ' . s:debug_file
                                    silent echon s:gettime() . ': ' . a:msg . "\n"
                                    redir END
                                endif

FUNCTION  neocomplcache#sources#syntax_complete#define()
Called 1 time
Total time:   0.000004
 Self time:   0.000004

count  total (s)   self (s)
    1              0.000003   return s:source

FUNCTION  <SNR>113_load()
Called 1 time
Total time:   0.017487
 Self time:   0.000104

count  total (s)   self (s)
    1   0.015293   0.000007   let scripts = s:_scripts()
    2              0.000004   for arg in a:000
    1              0.000007     let [name; as] = type(arg) == type([]) ? arg[: 1] : [arg, arg]
    1              0.000010     let target = split(join(as, ''), '\W\+')
    1              0.000002     let dict = self
    1              0.000002     while 1 <= len(target)
                                  let ns = remove(target, 0)
                                  if !has_key(dict, ns)
                                    let dict[ns] = {}
                                  endif
                                  if type(dict[ns]) == type({})
                                    let dict = dict[ns]
                                  else
                                    unlet dict
                                    break
                                  endif
                                endwhile
                            
    1              0.000002     if exists('dict')
    1   0.002119   0.000022       call extend(dict, s:_import(name, scripts))
    1              0.000001     endif
    1              0.000002     unlet arg
    1              0.000001   endfor
    1              0.000002   return self

FUNCTION  neocomplcache#helper#get_source_filetypes()
Called 1 time
Total time:   0.000104
 Self time:   0.000056

count  total (s)   self (s)
    1              0.000006   let filetype = (a:filetype == '') ? 'nothing' : a:filetype
                            
    1              0.000002   let filetype_dict = {}
                            
    1              0.000002   let filetypes = [filetype]
    1              0.000005   if filetype =~ '\.'
                                if exists('g:neocomplcache_ignore_composite_filetype_lists') && has_key(g:neocomplcache_ignore_composite_filetype_lists, filetype)
                                  let filetypes = [g:neocomplcache_ignore_composite_filetype_lists[filetype]]
                                else
                                  " Set composite filetype.
                                  let filetypes += split(filetype, '\.')
                                endif
                              endif
                            
    1              0.000003   if exists('g:neocomplcache_same_filetype_lists')
    2              0.000003     for ft in copy(filetypes)
    1              0.000008       let filetypes += split(get(g:neocomplcache_same_filetype_lists, ft, get(g:neocomplcache_same_filetype_lists, '_', '')), ',')
    1              0.000000     endfor
    1              0.000000   endif
                            
    1   0.000055   0.000007   return neocomplcache#util#uniq(filetypes)

FUNCTION  neocomplcache#init#_current_neocomplcache()
Called 1 time
Total time:   0.000024
 Self time:   0.000024

count  total (s)   self (s)
    1              0.000024   let b:neocomplcache = { 'context' : {      'input' : '',      'complete_pos' : -1,      'complete_str' : '',      'candidates' : [], }, 'lock' : 0, 'skip_next_complete' : 0, 'filetype' : '', 'context_filetype' : '', 'context_filetype_range' :    [[1, 1], [line('$'), len(getline('$'))+1]], 'completion_length' : -1, 'update_time_save' : &updatetime, 'foldinfo' : [], 'lock_sources' : {}, 'skipped' : 0, 'event' : '', 'cur_text' : '', 'old_cur_text' : '', 'complete_str' : '', 'complete_pos' : -1, 'candidates' : [], 'complete_results' : [], 'complete_sources' : [], 'manual_sources' : [], 'start_time' : reltime(),}

FUNCTION  <SNR>109_AutoUpdate()
Called 2 times
Total time:   0.000385
 Self time:   0.000295

count  total (s)   self (s)
    2   0.000035   0.000018     call s:debug('AutoUpdate called [' . a:fname . ']')
                            
                                " This file is being loaded due to a quickfix command like vimgrep, so
                                " don't process it
    2              0.000005     if exists('s:tagbar_qf_active')
                                    return
                                elseif exists('s:window_opening')
                                    " This can happen if another plugin causes the active window to change
                                    " with an autocmd during the initial Tagbar window creation. In that
                                    " case InitWindow() hasn't had a chance to run yet and things can
                                    " break. MiniBufExplorer does this, for example. Completely disabling
                                    " autocmds at that point is also not ideal since for example
                                    " statusline plugins won't be able to update.
                                    call s:debug('Still opening window, stopping processing')
                                    return
                                endif
                            
                                " Get the filetype of the file we're about to process
    2              0.000166     let bufnr = bufnr(a:fname)
    2              0.000013     let ftype = getbufvar(bufnr, '&filetype')
                            
                                " Don't do anything if we're in the tagbar window
    2              0.000003     if ftype == 'tagbar'
                                    call s:debug('In Tagbar window, stopping processing')
                                    return
                                endif
                            
                                " Only consider the main filetype in cases like 'python.django'
    2              0.000016     let sftype = get(split(ftype, '\.'), 0, '')
    2   0.000026   0.000012     call s:debug("Vim filetype: '" . ftype . "', " . "sanitized filetype: '" . sftype . "'")
                            
                                " Don't do anything if the file isn't supported
    2   0.000061   0.000012     if !s:IsValidFile(a:fname, sftype)
    2   0.000018   0.000008         call s:debug('Not a valid file, stopping processing')
    2              0.000004         let s:nearby_disabled = 1
    2              0.000001         return
                                endif
                            
                                let updated = 0
                            
                                " Process the file if it's unknown or the information is outdated.
                                " Testing the mtime of the file is necessary in case it got changed
                                " outside of Vim, for example by checking out a different version from a
                                " VCS.
                                if s:known_files.has(a:fname)
                                    let curfile = s:known_files.get(a:fname)
                                    " if a:force || getbufvar(curfile.bufnr, '&modified') ||
                                    if a:force || empty(curfile) || curfile.ftype != sftype || (filereadable(a:fname) && getftime(a:fname) > curfile.mtime)
                                        call s:debug('File data outdated, updating [' . a:fname . ']')
                                        call s:ProcessFile(a:fname, sftype)
                                        let updated = 1
                                    else
                                        call s:debug('File data seems up to date [' . a:fname . ']')
                                    endif
                                elseif !s:known_files.has(a:fname)
                                    call s:debug('New file, processing [' . a:fname . ']')
                                    call s:ProcessFile(a:fname, sftype)
                                    let updated = 1
                                endif
                            
                                let fileinfo = s:known_files.get(a:fname)
                            
                                " If we don't have an entry for the file by now something must have gone
                                " wrong, so don't change the tagbar content
                                if empty(fileinfo)
                                    call s:debug('fileinfo empty after processing [' . a:fname . ']')
                                    return
                                endif
                            
                                " Display the tagbar content if the tags have been updated or a different
                                " file is being displayed
                                if bufwinnr('__Tagbar__') != -1 && !s:paused && (s:new_window || updated || (!empty(s:known_files.getCurrent(0)) && a:fname != s:known_files.getCurrent(0).fpath))
                                    call s:RenderContent(fileinfo)
                                endif
                            
                                " Call setCurrent after rendering so RenderContent can check whether the
                                " same file is being redisplayed
                                if !empty(fileinfo)
                                    call s:debug('Setting current file [' . a:fname . ']')
                                    call s:known_files.setCurrent(fileinfo)
                                    let s:nearby_disabled = 0
                                endif
                            
                                call s:HighlightTag(0)
                                call s:debug('AutoUpdate finished successfully')

FUNCTION  SyntasticStatuslineFlag()
Called 7 times
Total time:   0.000487
 Self time:   0.000054

count  total (s)   self (s)
    7   0.000482   0.000049     return g:SyntasticLoclist.current().getStatuslineFlag()

FUNCTION  vital#of()
Called 1 time
Total time:   0.036757
 Self time:   0.001871

count  total (s)   self (s)
    1              0.001782   let files = globpath(&runtimepath, 'autoload/vital/' . a:name . '.vital')
    1              0.000010   let file = split(files, "\n")
    1              0.000003   if empty(file)
                                throw 'vital: version file not found: ' . a:name
                              endif
    1              0.000047   let ver = readfile(file[0], 'b')
    1              0.000003   if empty(ver)
                                throw 'vital: invalid version file: ' . a:name
                              endif
    1   0.034903   0.000017   return vital#_{substitute(ver[0], '\W', '', 'g')}#new()

FUNCTION  neocomplcache#init#_source()
Called 10 times
Total time:   0.006697
 Self time:   0.000888

count  total (s)   self (s)
   10   0.000284   0.000137   let default = { 'max_candidates' : 0, 'filetypes' : {}, 'hooks' : {}, 'matchers' : ['matcher_old'], 'sorters' : ['sorter_rank'], 'converters' : [      'converter_remove_next_keyword',      'converter_delimiter',      'converter_case',      'converter_abbr', ], 'neocomplcache__context' : copy(neocomplcache#get_context()), }
                            
   10              0.000098   let source = extend(copy(default), a:source)
                            
                              " Overwritten by user custom.
   10   0.000136   0.000055   let custom = neocomplcache#variables#get_custom().sources
   10              0.000063   let source = extend(source, get(custom, source.name, get(custom, '_', {})))
                            
   10              0.000022   let source.loaded = 0
                              " Source kind convertion.
   10              0.000048   if source.kind ==# 'plugin' || (!has_key(source, 'gather_candidates') &&  !has_key(source, 'get_complete_words'))
    4              0.000006     let source.kind = 'keyword'
    4              0.000006   elseif source.kind ==# 'ftplugin' || source.kind ==# 'complfunc'
                                " For compatibility.
                                let source.kind = 'manual'
                              else
    6              0.000007     let source.kind = 'manual'
    6              0.000004   endif
                            
   10              0.000017   if !has_key(source, 'rank')
                                " Set default rank.
    1              0.000003     let source.rank = (source.kind ==# 'keyword') ? 5 : empty(source.filetypes) ? 10 : 100
    1              0.000000   endif
                            
   10              0.000020   if !has_key(source, 'min_pattern_length')
                                " Set min_pattern_length.
    6              0.000024     let source.min_pattern_length = (source.kind ==# 'keyword') ? g:neocomplcache_auto_completion_start_length : 0
    6              0.000000   endif
                            
   10              0.000022   let source.neocomplcache__context.source_name = source.name
                            
                              " Note: This routine is for compatibility of old sources implementation.
                              " Initialize sources.
   10              0.000027   if empty(source.filetypes) && has_key(source, 'initialize')
    8              0.000009     try
    8   0.005629   0.000048       call source.initialize()
    8              0.000008     catch
                                  call neocomplcache#print_error(v:throwpoint)
                                  call neocomplcache#print_error(v:exception)
                                  call neocomplcache#print_error( 'Error occurred in source''s initialize()!')
                                  call neocomplcache#print_error( 'Source name is ' . source.name)
                                endtry
                            
    8              0.000015     let source.loaded = 1
    8              0.000005   endif
                            
   10              0.000010   return source

FUNCTION  Powerline#Functions#GetFilepath()
Called 7 times
Total time:   0.000429
 Self time:   0.000429

count  total (s)   self (s)
                            	" Recalculate the filepath when cwd changes.
    7              0.000053 	let cwd = getcwd()
    7              0.000034 	if exists("b:Powerline_cwd") && cwd != b:Powerline_cwd
                            		unlet! b:Powerline_filepath
                            	endif
    7              0.000014 	let b:Powerline_cwd = cwd
                            
    7              0.000014 	if exists('b:Powerline_filepath')
                            		return b:Powerline_filepath
                            	endif
                            
    7              0.000038 	let dirsep = has('win32') && ! &shellslash ? '\' : '/'
    7              0.000196 	let filepath = expand('%:p')
                            
    7              0.000020 	if empty(filepath)
    7              0.000006 		return ''
                            	endif
                            
                            	let ret = ''
                            
                            	if g:Powerline_stl_path_style == 'short'
                            		" Display a short path where the first directory is displayed with its
                            		" full name, and the subsequent directories are shortened to their
                            		" first letter, i.e. "/home/user/foo/foo/bar/baz.vim" becomes
                            		" "~/foo/f/b/baz.vim"
                            		"
                            		" This displays the shortest possible path, relative to ~ or the
                            		" current directory.
                            		let mod = (exists('+acd') && &acd) ? ':~:h' : ':~:.:h'
                            		let fpath = split(fnamemodify(filepath, mod), dirsep)
                            		let fpath_shortparts = map(fpath[1:], 'v:val[0]')
                            		let ret = join(extend([fpath[0]], fpath_shortparts), dirsep) . dirsep
                            	elseif g:Powerline_stl_path_style == 'relative'
                            		" Display a relative path, similar to the %f statusline item
                            		let ret = fnamemodify(filepath, ':~:.:h') . dirsep
                            	elseif g:Powerline_stl_path_style == 'full'
                            		" Display the full path, similar to the %F statusline item
                            		let ret = fnamemodify(filepath, ':h') . dirsep
                            	endif
                            
                            	if ret == ('.' . dirsep)
                            		let ret = ''
                            	endif
                            
                            	let b:Powerline_filepath = ret
                            	return ret

FUNCTION  <SNR>70_sub()
Called 7 times
Total time:   0.000139
 Self time:   0.000139

count  total (s)   self (s)
    7              0.000130   return substitute(a:str,'\v\C'.a:pat,a:rep,'')

FUNCTION  neocomplcache#util#set_default()
Called 9 times
Total time:   0.000117
 Self time:   0.000117

count  total (s)   self (s)
    9              0.000049   if !exists(a:var) || type({a:var}) != type(a:val)
    2              0.000007     let alternate_var = get(a:000, 0, '')
                            
    2              0.000010     let {a:var} = exists(alternate_var) ? {alternate_var} : a:val
    2              0.000002   endif

FUNCTION  <SNR>123_caching()
Called 1 time
Total time:   0.000866
 Self time:   0.000046

count  total (s)   self (s)
    1              0.000004   if !bufloaded(bufnr('%'))
                                return
                              endif
                            
    1   0.000037   0.000010   let key = neocomplcache#is_text_mode() ? 'text' : neocomplcache#get_context_filetype()
    2   0.000665   0.000009   for filetype in neocomplcache#get_source_filetypes(key)
    1              0.000005     if !has_key(s:dictionary_list, filetype) && !has_key(s:async_dictionary_list, filetype)
    1   0.000147   0.000010       call neocomplcache#sources#dictionary_complete#recaching(filetype)
    1              0.000000     endif
    1              0.000001   endfor

FUNCTION  Powerline#Functions#GetMode()
Called 7 times
Total time:   0.000261
 Self time:   0.000261

count  total (s)   self (s)
    7              0.000023 	let mode = mode()
                            
    7              0.000012 	if mode ==# 'v'
                            		let mode = get(g:, "Powerline_mode_v", "VISUAL")
                            	elseif mode ==# 'V'
                            		let mode = get(g:, "Powerline_mode_V", "V⋅LINE")
                            	elseif mode ==# ''
                            		let mode = get(g:, "Powerline_mode_cv", "V⋅BLOCK")
                            	elseif mode ==# 's'
                            		let mode = get(g:, "Powerline_mode_s", "SELECT")
                            	elseif mode ==# 'S'
                            		let mode = get(g:, "Powerline_mode_S", "S⋅LINE")
                            	elseif mode ==# ''
                            		let mode = get(g:, "Powerline_mode_cs", "S⋅BLOCK")
                            	elseif mode =~# '\vi'
                            		let mode = get(g:, "Powerline_mode_i", "INSERT")
                            	elseif mode =~# '\v(R|Rv)'
                            		let mode = get(g:, "Powerline_mode_R", "REPLACE")
                            	else
                            		" Fallback to normal mode
    7              0.000025 		let mode = get(g:, "Powerline_mode_n", "NORMAL")
    7              0.000004 	endif
                            
    7              0.000007 	return mode

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    2   0.073182   0.000346  neocomplcache#init#lazy()
    1   0.072008   0.005377  neocomplcache#init#_sources()
    3   0.047024   0.013095  <SNR>113__scripts()
    1   0.036757   0.001871  vital#of()
    1   0.034886   0.000048  vital#_13055f8#new()
  390   0.033473             <SNR>113__unify_path()
    1   0.018568   0.000064  <SNR>113_import()
    1   0.017487   0.000104  <SNR>113_load()
   10   0.007023   0.000226  neocomplcache#define_source()
   10   0.006697   0.000888  neocomplcache#init#_source()
    3   0.006214   0.000132  <SNR>113__import()
    3   0.006033   0.005691  <SNR>113__get_module_path()
    7   0.002749   0.000170  Powerline#Functions#fugitive#GetBranch()
    7   0.002579   0.000265  fugitive#statusline()
    1   0.002382   0.000063  614()
    7   0.001798   0.000093  fugitive#head()
    1   0.001763   0.000008  neocomplcache#has_vimproc()
    1   0.001755             neocomplcache#util#has_vimproc()
   35   0.001637   0.000576  neocomplcache#util#set_default_dictionary()
    7   0.001514   0.000254  <SNR>70_repo_head()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
  390              0.033473  <SNR>113__unify_path()
    3   0.047024   0.013095  <SNR>113__scripts()
    3   0.006033   0.005691  <SNR>113__get_module_path()
    1   0.072008   0.005377  neocomplcache#init#_sources()
    1   0.036757   0.001871  vital#of()
    1              0.001755  neocomplcache#util#has_vimproc()
   10   0.006697   0.000888  neocomplcache#init#_source()
    7   0.000969   0.000877  <SNR>70_repo_head_ref()
    1   0.001232   0.000864  621()
   35              0.000863  <SNR>114_set_dictionary_helper()
   92              0.000798  <SNR>111_escape()
    3              0.000789  <SNR>113__redir()
   35   0.001637   0.000576  neocomplcache#util#set_default_dictionary()
    7              0.000429  Powerline#Functions#GetFilepath()
    7              0.000374  310()
    1   0.001168   0.000370  neocomplcache#util#join_rtp()
    7              0.000348  Pl#Statusline()
    2   0.073182   0.000346  neocomplcache#init#lazy()
   14              0.000343  <SNR>70_repo()
    2   0.000385   0.000295  <SNR>109_AutoUpdate()

